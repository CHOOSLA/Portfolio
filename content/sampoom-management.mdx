---
id: 1
title: "삼품관리 - 자동차 제조 ERP"
description: "재고,생산,인사 등 7개 핵심 모듈로 구성된 자동차 제조 ERP입니다. FSD 아키텍처를 도입해 복잡한 모듈 간 의존성을 체계적으로 관리하고, OpenAPI Code Generator를 활용해 스키마부터 UI까지 이어지는 End-to-End Type Safety를 확보하는 데 주력했습니다."
accentColor: "#06b6d4"
tech:
  [
    "React",
    "TypeScript",
    "FSD(Feature Sliced Design) ",
    "OpenAPI Code Generator",
  ]
github: "https://github.com/CHOOSLA/Sampoom-Management-Frontend"
website: "https://www.samsam.autos"
thumbnail: "/sampoom.jpeg"
alt: "Sampoom Management Image"
category: "FrontEnd"
detailedDescription: "ERP 시스템을 개발하면서 FSD 아키텍처를 도입해 복잡한 모듈 간 의존성을 체계적으로 관리하고, OpenAPI Code Generator를 활용해 스키마부터 UI까지 이어지는 End-to-End Type Safety를 확보하는 데 주력했습니다."
overview:
  title: "자동차 제조 공정을 위한 엔터프라이즈 ERP 솔루션"
  description: "삼품관리는 자동차 제조 분야의 복잡한 비즈니스 프로세스를 디지털화하고 효율적으로 관리하기 위한 통합 ERP 프론트엔드 시스템입니다. 실제 현장에서 발생하는 방대한 데이터를 체계적으로 관리하고, 부서 간 실시간 협업을 지원하는 기능적인 인터페이스 구축에 집중했습니다."
  highlights:
    - "재고, 생산, 인사 등 7개 핵심 비즈니스 모듈 통합 관리"
    - "대규모 데이터를 효율적으로 처리하는 대시보드 및 리포팅 시스템"
    - "백엔드 OpenAPI 스키마 연동을 통한 실시간 데이터 정합성 유지"
    - "사용자 경험(UX) 중심의 직관적인 공정 관리 인터페이스"
challenges:
  - title: "복잡한 비즈니스 로직과 아키텍처 확장성 문제"
    description: "자동차 관리 시스템은 재고, 고객, 정비 이력 등 방대한 도메인을 포함합니다. 초기에는 컴포넌트 중심 구조로 시작했으나, 기능이 늘어날수록 프로젝트 구조가 비대해지고 유지보수가 어려워지는 한계에 직면했습니다."
    technicalDetails:
      - "컴포넌트 간 과도한 의존성으로 인한 코드 수정의 어려움"
      - "비즈니스 로직과 UI 로직의 혼재로 인한 낮은 테스트 가능성"
      - "팀 단위 개발 시 폴더 구조의 불명확함으로 인한 생산성 저하"
    solution:
      title: "Feature-Sliced Design(FSD) 계층형 아키텍처 도입"
      description: "프로젝트를 독립적인 역할을 가진 7개의 레이어로 나누어 관리하는 FSD 아키텍처를 도입했습니다. 이를 통해 각 모듈의 관심사를 분리하고 확장성 있는 구조를 확보했습니다."
      technicalDetails:
        - "Layers: app(설정), pages(페이지), widgets(결합), features(기능), entities(엔티티), shared(공통)로 계층화"
        - "관심사 분리를 통해 특정 기능 수정 시 타 모듈에 미치는 영향 최소화"
        - "신규 기능 추가 시 기존 폴더 구조를 해치지 않는 체계적인 확장성 확보"
      codeExample: |
        // folders structure
        src/
          app/         // entry point, providers
          pages/       // full pages
          widgets/     // blocks of features
          features/    // user actions (e.g., auth, search)
          entities/    // business entities (e.g., user, post)
          shared/      // non-business logic (e.g., UI, API)

  - title: "모듈 간 의존성 파편화 및 캡슐화 부족"
    description: "상위 레이어가 하위 레이어의 내부 구현에 직접 접근하면서 내부 로직이 외부로 노출되는 현상이 발생했습니다. 이는 모듈 간 결합도를 높여 작은 수정에도 전체 시스템이 흔들리는 원인이 되었습니다."
    technicalDetails:
      - "내부 파일의 직접 import로 인한 모듈 캡슐화 파괴"
      - "순환 참조(Circular Dependency) 발생 가능성 증대"
      - "코드 리뷰 시 어디까지가 공개된 API인지 파악하기 어려운 문제"
    solution:
      title: "Public API 패턴 및 ESLint 기반 Import 규칙 강제"
      description: "각 모듈에 index.ts(Public API)를 두어 외부 노출 범위를 제한하고, ESLint 플러그인을 사용하여 엄격한 계층 참조 규칙(Cross-import boundaries)을 적용했습니다."
      technicalDetails:
        - "Public API (index.ts) 패턴을 통한 모듈 인터페이스 명확화"
        - "상위 레이어가 하위 레이어만 참조 가능하도록 Lint 규칙 설정"
        - "모듈 세부 구현을 감춤으로써 낮은 결합도와 높은 응집도 달성"
      codeExample: |
        // features/auth/index.ts (Public API)
        export { LoginForm } from './ui/LoginForm';
        export { useAuth } from './model/useAuth';
        // internals are hidden from outside!

        // .eslintrc.js
        {
          "rules": {
            "boundaries/element-types": [
              "error",
              { "default": "disallow", "message": "Invalid layer relationship" }
            ]
          }
        }

  - title: "서버 상태와 전역 상태의 비효율적인 동기화"
    description: "ERP 시스템 특성상 실시간 데이터 정합성이 중요했습니다. Redux나 Zustand만으로는 서버 데이터의 캐싱, 리로딩, 로딩 상태 관리 등의 복잡한 서버 상태를 효율적으로 다루기 버거웠습니다."
    technicalDetails:
      - "서버 데이터 응답을 직접 전역 Store에 저장하면서 생기는 데이터 동기화 이슈"
      - "로딩 및 에러 처리 분산으로 인한 비지니스 로직 오염"
      - "동일 데이터의 중복 API 호출로 인한 자원 낭비"
    solution:
      title: "Zustand와 React Query를 활용한 상태 관리 이원화"
      description: "순수 UI 상태나 인증 정보는 Zustand로, 서버 데이터는 React Query로 분리하여 관리했습니다. 이를 통해 데이터의 생명주기를 명확히 구분하고 캐싱 전략을 최적화했습니다."
      technicalDetails:
        - "React Query (Tanstack Query)를 통한 서버 데이터 가로채기 및 캐싱"
        - "Zustand를 사용하여 최소한의 UI 클라이언트 상태(사이드바 상태 등)만 유지"
        - "불필요한 리렌더링 방지 및 낙관적 업데이트(Optimistic UI) 구현"
      codeExample: |
        // features/car-management/api/useCars.ts
        import { useQuery } from '@tanstack/react-query'
        import { carsApi } from '@/shared/api'

        export const useCars = () => {
          return useQuery({
            queryKey: ['cars'],
            queryFn: carsApi.getAll,
            staleTime: 5 * 60 * 1000, // 5 mins cache
          })
        }

  - title: "백엔드-프론트엔드 간 타입 불일치와 유지보수 비용"
    description: "자동차 제조 공정의 수많은 필드와 복잡한 스키마가 변경될 때마다 프론트엔드의 타입을 수동으로 업데이트하는 것은 매우 위험하고 비효율적이었습니다."
    technicalDetails:
      - "백엔드 API 변경 시 프론트엔드 런타임 에러 발생 위험"
      - "수천 줄의 TypeScript 인터페이스 수동 작성에 따른 오타 및 누락"
      - "API 명세 문서(Swagger)와 실제 코드 간의 괴리"
    solution:
      title: "OpenAPI Code Generator 기반 End-to-End Type Safety 확보"
      description: "백엔드의 OpenAPI(Swagger) 사양서를 기반으로 TypeScript 스키마와 API Fetch 함수를 자동 생성하는 파이프라인을 구축했습니다."
      technicalDetails:
        - "openapi-generator-cli를 통한 타입 세이프한 API SDK 자동 생성"
        - "백엔드 변경 사항 발생 시 명령어 한 줄로 프론트엔드 타입 동기화"
        - "Zod를 활용한 런타임 데이터 검증(Validation) 연동"
      codeExample: |
        // package.json script
        "generate:api": "openapi-generator-cli generate -i [API_URL] -g typescript-fetch -o src/shared/api/generated"

        // Usage in Code
        import { CarDto } from '@/shared/api/generated';

        const car: CarDto = {
          id: 1,
          name: 'Santa Fe', // Type Checked!
        };

retrospective:
  title: "단순히 기능을 구현하는 것을 넘어, 지속 가능한 소프트웨어를 만들기 위해 어떤 구조적 고민이 필요한지 깊이 이해하게 된 계기가 되었습니다."
  description:
    - "FSD 아키텍처를 처음 도입했을 때는 파일 구조가 너무 파편화되어 있다고 느껴져 팀원들 모두 적응하는 데 시간이 걸렸습니다. 하지만 프로젝트 규모가 커지고 기능이 복잡해질수록, 코드를 어디에 두어야 할지에 대한 고민이 사라지고 기계적인 개발이 가능해지는 경험을 했습니다."
    - "특히 OpenAPI Code Generator를 도입한 것은 신의 한 수였습니다. 백엔드 API가 변경될 때마다 프론트엔드에서 일일이 타입을 수정하던 수고가 사라졌고, 런타임 에러가 획기적으로 줄어들었습니다."
    - "아쉬웠던 점은 초반에 공통 컴포넌트(Shared UI) 설계에 너무 많은 시간을 쏟았다는 점입니다. 모든 것을 재사용 가능하게 만들겠다는 욕심이 오히려 초기 개발 속도를 늦췄습니다. 다음 프로젝트에서는 YAGNI(You Aren't Gonna Need It) 원칙을 더 철저히 지키며, 중복이 3번 이상 발생할 때 리팩토링하는 방식으로 접근하고 싶습니다."
---
